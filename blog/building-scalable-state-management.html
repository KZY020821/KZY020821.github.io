<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Building Scalable State Management with TanStack Query + Redux | Khor Ze Yi</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Learn how to build scalable state management in React applications using TanStack Query for server state and Redux for client state. A hybrid architecture that eliminates redundant API calls and improves performance by 40%." />
    <meta name="keywords" content="TanStack Query, React Query, Redux, state management, React, Next.js, server state, client state, API caching, performance optimization, frontend architecture, JavaScript, TypeScript, web development, software engineering" />
    <meta name="author" content="Khor Ze Yi" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://kzy020821.github.io/blog/building-scalable-state-management.html" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://kzy020821.github.io/blog/building-scalable-state-management.html" />
    <meta property="og:title" content="Building Scalable State Management with TanStack Query + Redux" />
    <meta property="og:description" content="A hybrid approach combining TanStack Query for server state and Redux for client state to eliminate redundant API calls and improve React application performance by 40%." />
    <meta property="og:image" content="https://kzy020821.github.io/src/assets/potrait.png" />
    <meta property="og:site_name" content="Khor Ze Yi - Software Engineer" />
    <meta property="article:author" content="Khor Ze Yi" />
    <meta property="article:published_time" content="2024-12-28" />
    <meta property="article:tag" content="TanStack Query" />
    <meta property="article:tag" content="Redux" />
    <meta property="article:tag" content="React" />
    <meta property="article:tag" content="State Management" />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://kzy020821.github.io/blog/building-scalable-state-management.html" />
    <meta name="twitter:title" content="Building Scalable State Management with TanStack Query + Redux" />
    <meta name="twitter:description" content="A hybrid approach combining TanStack Query for server state and Redux for client state to eliminate redundant API calls and improve React application performance by 40%." />
    <meta name="twitter:image" content="https://kzy020821.github.io/src/assets/potrait.png" />
    
    <!-- Structured Data / JSON-LD -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "Building Scalable State Management with TanStack Query + Redux",
      "description": "Learn how to build scalable state management in React applications using TanStack Query for server state and Redux for client state.",
      "image": "https://kzy020821.github.io/src/assets/potrait.png",
      "author": {
        "@type": "Person",
        "name": "Khor Ze Yi",
        "url": "https://kzy020821.github.io"
      },
      "publisher": {
        "@type": "Person",
        "name": "Khor Ze Yi"
      },
      "datePublished": "2024-12-28",
      "dateModified": "2024-12-28",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://kzy020821.github.io/blog/building-scalable-state-management.html"
      },
      "keywords": ["TanStack Query", "Redux", "React", "state management", "frontend architecture", "JavaScript", "TypeScript", "performance optimization"]
    }
    </script>
    
    <link rel="icon" type="image/x-icon" href="/src/assets/moji.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700;900&family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/src/shared.css" />
  </head>
  <body>
    <!-- Navigation -->
    <nav class="main-nav">
      <div class="nav-container">
        <a href="/" class="nav-logo gradient-text">KZY</a>
        <div class="nav-links">
          <a href="/" class="nav-link">Home</a>
          <a href="/projects.html" class="nav-link">Projects</a>
          <a href="/blog.html" class="nav-link active">Blog</a>
        </div>
        <button class="nav-toggle" aria-label="Toggle menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
    </nav>

    <!-- Mobile Menu -->
    <div class="mobile-menu">
      <a href="/" class="mobile-link">Home</a>
      <a href="/projects.html" class="mobile-link">Projects</a>
      <a href="/blog.html" class="mobile-link active">Blog</a>
    </div>

    <article class="blog-post-container">
      <!-- Back Button -->
      <a href="/blog.html" class="back-to-blog">
        <svg viewBox="0 0 24 24">
          <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
        </svg>
        Back to Blog
      </a>

      <!-- Blog Post Header -->
      <header class="blog-post-header card reveal">
        <div class="blog-post-meta">
          <span class="blog-date">December 28, 2024</span>
          <span class="blog-category">Architecture</span>
          <span class="read-time">5 min read</span>
        </div>
        <h1 class="blog-post-title gradient-text">Building Scalable State Management with TanStack Query + Redux</h1>
        <p class="blog-post-subtitle">
          A hybrid approach that combines the best of server state and client state management 
          to eliminate redundant API calls and improve application performance by 40%.
        </p>
        <div class="blog-post-tags">
          <span class="tag">TanStack Query</span>
          <span class="tag">Redux</span>
          <span class="tag">React</span>
          <span class="tag">Performance</span>
        </div>
      </header>

      <!-- Blog Post Content -->
      <div class="blog-post-content card reveal">
        <section class="blog-section">
          <h2>The Problem with Traditional State Management</h2>
          <p>
            After migrating several enterprise applications from legacy systems, I discovered a common 
            pattern: applications were making redundant API calls, managing server state in Redux stores 
            (which wasn't designed for this), and struggling with cache invalidation.
          </p>
          <p>
            The traditional approach of putting everything in Redux leads to:
          </p>
          <ul>
            <li>Boilerplate code for every API endpoint (actions, reducers, selectors)</li>
            <li>Manual cache management and invalidation</li>
            <li>No built-in loading/error states</li>
            <li>Redundant network requests when components remount</li>
          </ul>
        </section>

        <section class="blog-section">
          <h2>The Hybrid Architecture</h2>
          <p>
            The solution I developed separates concerns clearly:
          </p>
          <div class="code-block">
            <div class="code-header">
              <span>Architecture Overview</span>
            </div>
            <pre><code>┌─────────────────────────────────────────────┐
│              React Components               │
├─────────────────────────────────────────────┤
│                                             │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │  TanStack Query │  │     Redux       │  │
│  │  (Server State) │  │ (Client State)  │  │
│  │                 │  │                 │  │
│  │  • API Data     │  │  • UI State     │  │
│  │  • Caching      │  │  • User Prefs   │  │
│  │  • Refetching   │  │  • Form Data    │  │
│  │  • Pagination   │  │  • Filters      │  │
│  └────────┬────────┘  └────────┬────────┘  │
│           │                    │           │
│           └────────┬───────────┘           │
│                    │                       │
├────────────────────┼───────────────────────┤
│               Redis Cache                  │
│           (Session + API Cache)            │
└─────────────────────────────────────────────┘</code></pre>
          </div>
        </section>

        <section class="blog-section">
          <h2>Implementation: TanStack Query for Server State</h2>
          <p>
            TanStack Query handles all server-side data with automatic caching, background refetching, 
            and intelligent cache invalidation:
          </p>
          <div class="code-block">
            <div class="code-header">
              <span>hooks/useProducts.ts</span>
            </div>
            <pre><code>import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productApi } from '@/api/products';

export const useProducts = (filters: ProductFilters) => {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productApi.getAll(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 30 * 60 * 1000,   // 30 minutes
  });
};

export const useUpdateProduct = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: productApi.update,
    onSuccess: (data) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['products'] });
      // Optimistically update the cache
      queryClient.setQueryData(['product', data.id], data);
    },
  });
};</code></pre>
          </div>
        </section>

        <section class="blog-section">
          <h2>Implementation: Redux for Client State</h2>
          <p>
            Redux remains perfect for complex client-side state that needs to be shared across 
            components—UI preferences, filters, and form state:
          </p>
          <div class="code-block">
            <div class="code-header">
              <span>store/slices/uiSlice.ts</span>
            </div>
            <pre><code>import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface UIState {
  sidebarOpen: boolean;
  activeFilters: string[];
  selectedProductIds: string[];
  viewMode: 'grid' | 'list';
}

const uiSlice = createSlice({
  name: 'ui',
  initialState: {
    sidebarOpen: true,
    activeFilters: [],
    selectedProductIds: [],
    viewMode: 'grid',
  } as UIState,
  reducers: {
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    setFilters: (state, action: PayloadAction&lt;string[]&gt;) => {
      state.activeFilters = action.payload;
    },
    selectProducts: (state, action: PayloadAction&lt;string[]&gt;) => {
      state.selectedProductIds = action.payload;
    },
  },
});</code></pre>
          </div>
        </section>

        <section class="blog-section">
          <h2>Results: 40% Performance Improvement</h2>
          <p>
            After implementing this hybrid architecture across our CRM platform:
          </p>
          <div class="stats-grid">
            <div class="stat-item">
              <span class="stat-value gradient-text">40%</span>
              <span class="stat-label">Faster Load Times</span>
            </div>
            <div class="stat-item">
              <span class="stat-value gradient-text">60%</span>
              <span class="stat-label">Fewer API Calls</span>
            </div>
            <div class="stat-item">
              <span class="stat-value gradient-text">50%</span>
              <span class="stat-label">Less Boilerplate</span>
            </div>
          </div>
          <p>
            The key insight is that <strong>server state and client state have fundamentally different 
            lifecycles and requirements</strong>. Using the right tool for each leads to cleaner code, 
            better performance, and happier developers.
          </p>
        </section>

        <section class="blog-section">
          <h2>Key Takeaways</h2>
          <ul>
            <li><strong>Separate concerns:</strong> Use TanStack Query for server state, Redux for client state</li>
            <li><strong>Leverage caching:</strong> TanStack Query's staleTime and gcTime eliminate redundant requests</li>
            <li><strong>Optimistic updates:</strong> Provide instant feedback while mutations are in flight</li>
            <li><strong>Layer with Redis:</strong> Add server-side caching for even better performance</li>
          </ul>
        </section>
      </div>

      <!-- Author Card -->
      <div class="blog-author-card card reveal">
        <img src="/src/assets/potrait.png" alt="Khor Ze Yi" class="author-avatar" />
        <div class="author-info">
          <h3>Written by Khor Ze Yi</h3>
          <p>Software Engineer specializing in React, Next.js, and building scalable web applications.</p>
          <div class="author-links">
            <a href="https://github.com/KZY020821" target="_blank" class="pill-link">
              <svg viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
              GitHub
            </a>
            <a href="https://www.linkedin.com/in/khorzeyi" target="_blank" class="pill-link">
              <svg viewBox="0 0 24 24"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
              LinkedIn
            </a>
          </div>
        </div>
      </div>

      <!-- Navigation -->
      <div class="blog-navigation card reveal">
        <a href="/blog.html" class="blog-nav-link">
          <span class="nav-direction">← Back to</span>
          <span class="nav-title">All Posts</span>
        </a>
        <a href="/blog/face-recognition-cnn-twins.html" class="blog-nav-link next">
          <span class="nav-direction">Next Post →</span>
          <span class="nav-title">Training Face Recognition CNN</span>
        </a>
      </div>
    </article>

    <footer class="footer">
      <p class="footer-text">Built with ♥ by Khor Ze Yi // 2024</p>
    </footer>

    <script src="/src/shared.js"></script>
  </body>
</html>
